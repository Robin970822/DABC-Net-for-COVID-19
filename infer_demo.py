# -*- coding: utf-8 -*-
"""Infer_demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bgqFuXF6li5HNCKtmtXDUGx1ZzJgOxJn
"""

import os

# from google.colab import drive
# drive.mount('/content/drive')

# cd drive/My\ Drive/Colab\ Notebooks/DABC-Net(colab)/

# pip install SimpleITK scipy==1.1 tensorflow-gpu==1.15 keras==2.2.4 xgboost==1.1.0 scikit-learn==0.21.3

"""# Run segmentation"""

import numpy as np

import tensorflow as tf

tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)

from read_all_data_from_nii_pipe import read_from_nii

import tensorflow as tf
from keras.backend.tensorflow_backend import set_session

config = tf.ConfigProto()
config.gpu_options.allow_growth = True
set_session(tf.Session(config=config))


def infer_colab(nii_path='', save_path='', sform_code=0, usage='covid'):
    save_path = save_path + '/*'
    nii_path = nii_path + '/*'

    all_src_data = read_from_nii(nii_path=nii_path, Hu_window=(-1024, 512), need_rotate=True)

    all_src_data = np.expand_dims(all_src_data, -1)

    all_mask_data = np.zeros_like(all_src_data)

    '''

    '''
    from evaluate_performance_pipeline import local_evaluate

    print('\n**********\tInferring CT scans:\t**********\n')

    test_vol = all_src_data
    test_mask = all_mask_data

    if test_vol.shape[0] % 4 != 0:
        cut = test_vol.shape[0] % 4
        test_vol = test_vol[:-cut]
        test_mask = test_mask[:-cut]
    assert test_vol.shape[0] % 4 == 0

    '''
    infer
    '''
    import models as Model

    if usage == 'covid':
        name = 'weight/Covid_05112327'
    elif usage == 'lung':
        name = 'weight/model_05090017'
    else:
        print('Please select correct model!')
        return None

    model = Model.DABC(input_size=(4, 256, 256, 1),
                       load_weighted=name)

    pred = local_evaluate(test_vol, test_mask, model, model_name_id=None, only_infer=True, )

    from read_all_data_from_nii_pipe import save_pred_to_nii

    save_pred_to_nii(pred=pred, save_path=save_path.replace('*', ''), ref_path=nii_path,
                     need_resize=True, need_rotate=True)


# Segment lesions
# input='input'
# output='output'
input_path = '2020035365'
output_path = '2020035365_output/covid'
infer_colab(input_path, output_path)

# Segment lung
# output='output_lung'
output_path = '2020035365_output/lung'
infer_colab(input_path, output_path, usage='lung')

from postprocess_lung import remove_small_objects

# remove_small_objects('output_lung')  # (This step is optional.)
remove_small_objects('2020035365_output/lung')

from infer_uncertainty_colab import infer_uncertainty

infer_uncertainty('2020035365/2020035365_0204_3050_20200204184413_4.nii.gz', '2020035365_output/uncertainty',
                  sample_value=5, uc_chosen='Both')

"""## Visualisation

### Segmentation results
"""

import numpy as np
from glob import glob
from utils_mri import get_itk_array
import cv2

from skimage.util import montage
from warnings import warn


def montage_nd(in_img):
    if len(in_img.shape) > 3:
        return montage(np.stack([montage_nd(x_slice) for x_slice in in_img], 0))
    elif len(in_img.shape) == 3:
        return montage(in_img)
    else:
        warn('Dimension of input less than 3, returning original', RuntimeWarning)
        return in_img


input_path = '2020035365'
output_lung_path = '2020035365_output/lung'
output_covid_path = '2020035365_output/covid'

slice_id = [175, 162, 195, 195, 195, 195, 195, 195]
slice_count = 5  # slices to plot for each scan.

vol = []
for nii_index in range(len(glob(input_path + '/*'))):
    volume = get_itk_array(glob(input_path + '/*')[nii_index])
    vol_slice = volume[slice_id[nii_index]:(slice_id[nii_index] + slice_count)]
    for i in range(vol_slice.shape[0]):
        vol_slice[i] = cv2.flip(vol_slice[i], 0)
    vol.append(vol_slice)
vol = np.array(vol)
vol = np.expand_dims(vol, -1)

vol_lung = []
for nii_index in range(len(glob(output_lung_path + '/*'))):
    volume = get_itk_array(glob(output_lung_path + '/*')[nii_index])
    vol_slice = volume[slice_id[nii_index]:(slice_id[nii_index] + slice_count)]
    for i in range(vol_slice.shape[0]):
        vol_slice[i] = cv2.flip(vol_slice[i], 0)
    vol_lung.append(vol_slice)
vol_lung = np.array(vol_lung)
vol_lung = np.expand_dims(vol_lung, -1)

vol_covid = []
for nii_index in range(len(glob(output_covid_path + '/*'))):
    volume = get_itk_array(glob(output_covid_path + '/*')[nii_index])
    vol_slice = volume[slice_id[nii_index]:(slice_id[nii_index] + slice_count)]
    for i in range(vol_slice.shape[0]):
        vol_slice[i] = cv2.flip(vol_slice[i], 0)
    vol_covid.append(vol_slice)
vol_covid = np.array(vol_covid)
vol_covid = np.expand_dims(vol_covid, -1)

import matplotlib.pyplot as plt

fig, (ax1, ax2, ax3) = plt.subplots(1, 3,
                                    figsize=(30, 10)
                                    )

# print('vol.shape:',vol.shape)
# print('vol_lung.shape:',vol_lung.shape)
# print('vol_covid.shape:',vol_covid.shape)

ax1.imshow(montage_nd(vol[..., 0]), cmap='gray')
ax1.set_title('Raw')
ax2.imshow(montage_nd(vol_lung[..., 0]), cmap='gray')
ax2.set_title('Lung')
ax3.imshow(montage_nd(vol_covid[..., 0]), cmap='gray')
ax3.set_title('Lesions')

plt.savefig('results.png')

"""<center>Different timepoint CT scans of one patient.</center>

## Uncertainty
"""

import numpy as np
import nibabel as nib
import matplotlib.pyplot as plt


def plot_uncertainty(name_id='2020035365_0204_3050_20200204184413_4.nii.gz', slice_id=175, sform_code=1):
    # name_id = '2020035365_0204_3050_20200204184413_4.nii.gz'
    # sform_code=1

    # slice_id = 175

    rawimg = nib.load(r'2020035365/' + name_id).get_fdata()
    aleatoric = nib.load(r'2020035365_output/uncertainty/' + 'aleatoric_' + name_id).get_fdata()
    epistemic = nib.load(r'2020035365_output/uncertainty/' + 'epistemic_' + name_id).get_fdata()

    slices_num = rawimg.shape[-1]

    our = nib.load(r'2020035365_output/covid/' + name_id).get_fdata()

    our = our[:, :, slice_id]

    rawimg = rawimg[:, :, slice_id];
    rawimg[rawimg < -1024] = -1024;
    rawimg[rawimg > 255] = 255
    # gt = gt[:,:,slice_id]
    aleatoric = aleatoric[:, :, slice_id]
    epistemic = epistemic[:, :, slice_id]

    # sform_code==1:rot90,1. else:rot90,-1
    if sform_code:
        rotate = 1
        aleatoric = np.rot90(aleatoric, rotate)
        epistemic = np.rot90(epistemic, rotate)
        rawimg = np.rot90(rawimg, rotate)
        our = np.rot90(our, rotate)
    else:
        rotate = -1
        import cv2
        aleatoric = np.rot90(aleatoric, rotate);
        aleatoric = cv2.flip(aleatoric, 1)
        epistemic = np.rot90(epistemic, rotate);
        epistemic = cv2.flip(epistemic, 1)
        rawimg = np.rot90(rawimg, rotate);
        rawimg = cv2.flip(rawimg, 1)
        our = np.rot90(our, rotate);
        our = cv2.flip(our, 1)

    from transparent_imshow import transp_imshow

    def overlay(_src, _pred, _gt, need_crop=True, add_text=False, need_save=False,
                need_overlay=True, need_overlay_alea=None, need_overlay_epis=False, aleatoric=None, epistemic=None,
                need_overlay_alea_scale=False):
        # need_save:'img_File_name'
        rawimg = _src
        prediction = _pred
        gt = _gt

        if need_crop:  # (row1,row2,c1,c2)
            if 'cor' in need_save:
                need_crop = (30, 350, 20, -20)
                rawimg = rawimg[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
                prediction = prediction[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
                gt = gt[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
            if 'radio' in need_save:
                need_crop = (90, 570, 0, -1)
                rawimg = rawimg[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
                prediction = prediction[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
                gt = gt[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]

        plt.imshow(rawimg, cmap='gray', )
        if need_overlay:
            TP = prediction * gt
            FP = prediction * (np.ones_like(gt) - gt)
            FN = (1 - prediction) * gt
            transp_imshow(TP, cmap='RdYlGn', alpha=0.7)
            transp_imshow(FP, cmap='cool', alpha=0.7)  #
            transp_imshow(FN, cmap='Wistia', alpha=0.7)
        if need_overlay_epis:
            if need_crop:
                epistemic = epistemic[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
            plt.imshow(rawimg, cmap='gray', )
            transp_imshow(epistemic, cmap='autumn_r', alpha=1.0)
        if need_overlay_alea:
            if need_crop:
                aleatoric = aleatoric[need_crop[0]:need_crop[1], need_crop[2]:need_crop[3]]
            plt.imshow(rawimg, cmap='gray', )

            #         print(need_overlay_alea)
            #         print('vmin: ',0.5)
            transp_imshow(aleatoric, cmap='winter',

                          )
        if add_text:
            _dice = dice(prediction, gt)
            _dice = np.round(_dice, 2)
            font = {'family': 'Times New Roman',  # serif
                    # 'style': 'italic',
                    'weight': 'normal',
                    'color': 'red',
                    'size': 20
                    }
            plt.text(5, -5, s='Dice: ' + str(_dice), color='black',
                     # horizontalalignment='right',
                     # verticalalignment='top',
                     fontdict=font,
                     )
        plt.axis('off')
        # plt.xticks([])  
        # plt.yticks([])
        if need_save:  # False or file string
            plt.gca().xaxis.set_major_locator(plt.NullLocator())
            plt.gca().yaxis.set_major_locator(plt.NullLocator())

            plt.savefig(need_save,
                        bbox_inches='tight',
                        dpi=300, pad_inches=0.0)
        plt.show()

    print('Slice: {0}/{1}'.format(slice_id, slices_num))
    print('Raw image:')
    overlay(rawimg, np.zeros_like(rawimg), np.zeros_like(rawimg), need_crop=False, need_overlay=False, add_text=False,
            need_save='2020035365_output/' + name_id + str(slice_id) + '_src_.png')
    print('Aleatoric uncertainty:')
    overlay(rawimg, np.zeros_like(rawimg), np.zeros_like(rawimg), need_crop=False, need_overlay=False,
            aleatoric=aleatoric, need_overlay_alea=True, add_text=False,
            need_save='2020035365_output/' + name_id + str(slice_id) + '_Uc_alea_.png')
    print('Epistemic uncertainty:')
    overlay(rawimg, np.zeros_like(rawimg), np.zeros_like(rawimg), need_crop=False, need_overlay=False,
            epistemic=epistemic, need_overlay_epis=True, add_text=False,
            need_save='2020035365_output/' + name_id + str(slice_id) + '_Uc_epis_.png')


plot_uncertainty(name_id='2020035365_0204_3050_20200204184413_4.nii.gz', slice_id=175)

plot_uncertainty(name_id='2020035365_0204_3050_20200204184413_4.nii.gz', slice_id=150)

"""#Early triage of critically ill

## Load data
  In this section, we present one mild patient and one severe patient with multi-scans to show progress of the disease and illustrate our model performance.
"""

# pip install SimpleITK xgboost==1.1.0 scikit-learn==0.21.3 scipy==1.1

from read_all_data_from_nii_pipe import read_from_nii
import pandas as pd

# severe patient
meta_path = 'meta/2020035365.csv'
meta = pd.read_csv(meta_path, index_col=[0])

raw_data = read_from_nii(r'2020035365/*').astype('float32')  # (3201, 256, 256)  0-1
lung = read_from_nii(r'2020035365_output/lung/*').astype('float32')  # (3201, 256, 256)
lesion = read_from_nii(r'2020035365_output/covid/*').astype('float32')  # (3201, 256, 256)

# mild patient
meta_path_mild = 'meta/2020035021.csv'
meta_mild = pd.read_csv(meta_path_mild, index_col=[0])

import os
import cv2
import json
import pickle
import numpy as np
import pandas as pd
import SimpleITK as itk
import seaborn as sns
from matplotlib import pyplot as plt


def get_days(datetime):
    return datetime.days


def get_sex(PatientSex):
    return 1 if PatientSex is 'M' else 0


def min_max_scalar(x, min, max):
    return (x - min) / (max - min)


def crop_volume(volume, crop):
    volume_ = volume.copy()
    volume_[:crop[0]] = 0
    volume_[-crop[1]:] = 0
    return volume_


def prob2binary(prob, thres=0.5):
    res = np.zeros_like(prob)
    res[prob > 0.5] = 1
    return res


def get_itk_array(filenameOrImage):
    reader = itk.ImageFileReader()
    reader.SetFileName(filenameOrImage)
    image = reader.Execute()
    imageArray = itk.GetArrayFromImage(image)  # (slices, length, height)
    spacing = image.GetSpacing()
    return imageArray, spacing


def make_itk_image(imageArray, protoImage=None):
    image = itk.GetImageFromArray(imageArray)
    if protoImage is not None:
        image.CopyInformation(protoImage)

    return image


def write_itk_imageArray(imageArray, filename, src_nii=None):
    """ Write 3D ndarray into .nii file
    """
    img = make_itk_image(imageArray, src_nii)
    write_itk_image(img, filename)


def write_itk_image(image, filename):
    writer = itk.ImageFileWriter()
    writer.SetFileName(filename)

    if filename.endswith('.nii'):
        Warning('You are converting nii, be careful with type conversions')

    writer.Execute(image)
    return


def resize(data, shape):
    mask = np.zeros(shape)
    for i in range(shape[0]):
        mask[i, :, :] = cv2.resize(data[i, :, :], (shape[1], shape[2]))
    return mask


def save_nii(raw, lung, lesion, meta, crop=[0, 0]):
    """ Save raw data, lung segmentation, lesion segmentation as .nii.gz file
    """
    former_slice = 0
    for index, row in meta.iterrows():
        filename = row['filename']
        filename = os.path.basename(filename)
        slices = row['slice']
        origin_shape = eval(row['shape'])
        total_slice = lung.shape[0]
        current_slice = np.min([former_slice + slices, total_slice])

        raw_volume = raw[former_slice:current_slice]
        lung_volume = lung[former_slice:current_slice]
        lesion_volume = lesion[former_slice:current_slice]
        lesion_volume = lesion_volume * lung_volume
        if crop[0] > 0:
            lung_volume = crop_volume(lung_volume, (np.array(crop) * slices).astype('int'))
            lesion_volume = crop_volume(lesion_volume, (np.array(crop) * slices).astype('int'))

        lung_volume = resize(lung_volume, origin_shape)
        lesion_volume = resize(lesion_volume, origin_shape)
        raw_volume = resize(raw_volume, origin_shape)

        lung_path = os.path.join(lung_root, filename)
        lesion_path = os.path.join(lesion_root, filename)
        raw_path = os.path.join(raw_root, filename)
        print(lung_path)
        print(lesion_path)
        print(raw_path)

        write_itk_imageArray(lung_volume, lung_path)
        write_itk_imageArray(lesion_volume, lesion_path)
        write_itk_imageArray(raw_volume, raw_path)
        former_slice = current_slice


def get_z(lesion):
    z = 0
    for i in range(lesion.shape[0]):
        z = z + i * np.sum(lesion[i, :, :])
    return z / (np.sum(lesion) + 1e-5)


def get_left_right(data, mid):
    right = data[:, :, :mid]
    left = data[:, :, mid:mid * 2]
    return left, right


def get_consolidation(raw_data, lung, lesion, thres=0.5):
    """ Consolidation from raw, lung and lesion
    """
    lung = prob2binary(lung)
    lesion = prob2binary(lesion)

    lung_lesion_union = lesion.astype(np.uint8) | lung.astype(np.uint8)

    lung_lesion_union = lung_lesion_union.astype(np.uint8)
    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5))
    lung_lesion_union_close = cv2.morphologyEx(
        lung_lesion_union, cv2.MORPH_CLOSE, kernel)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (3, 3))
    lung_lesion_union_open = cv2.morphologyEx(
        lung_lesion_union_close, cv2.MORPH_CLOSE, kernel)

    lung_lesion_union_open_area = raw_data * \
                                  lung_lesion_union_open[:raw_data.shape[0]]

    _, thres_image = cv2.threshold(
        lung_lesion_union_open_area, thres, 1, cv2.THRESH_BINARY)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5))
    thres_image = cv2.morphologyEx(thres_image, cv2.MORPH_CLOSE, kernel)
    kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 1))
    thres_image_open = cv2.morphologyEx(thres_image, cv2.MORPH_OPEN, kernel)

    return thres_image_open


def calculate_volume(raw, lung, lesion, meta, crop=[0, 0]):
    lung = prob2binary(lung)
    lesion = prob2binary(lesion)
    lung_lesion = lesion * lung
    former_slice = 0
    res_list = []
    for index, row in meta.iterrows():
        slices = row['slice']
        spacing = eval(row['spacing'])
        origin_shape = eval(row['shape'])
        size_factor = (origin_shape[1] * origin_shape[2]
                       ) / (lung.shape[1] * lung.shape[2])
        voxel_size = spacing[0] * spacing[1] * spacing[2] * size_factor

        total_slice, height, width = lung.shape
        mid = int(width / 2)
        current_slice = np.min([former_slice + slices, total_slice])

        lung_current = lung[former_slice:current_slice]
        lesion_current = lesion[former_slice:current_slice]
        lung_lesion_current = lung_lesion[former_slice:current_slice]
        raw_current = raw[former_slice:current_slice]
        if crop[0] > 0:
            lung_current = crop_volume(
                lung_current, (np.array(crop) * slices).astype('int'))
            lesion_current = crop_volume(
                lesion_current, (np.array(crop) * slices).astype('int'))
            lung_lesion_current = crop_volume(
                lung_lesion_current, (np.array(crop) * slices).astype('int'))

        left_lung, right_lung = get_left_right(lung_current, mid)
        left_lesion, right_lesion = get_left_right(lung_lesion_current, mid)
        left_raw, right_raw = get_left_right(raw_current, mid)

        consolidation = get_consolidation(
            raw_current, lung_current, lesion_current)
        lesion_consolidation = lung_lesion_current * consolidation
        left_consolidation, right_consolidation = get_left_right(
            lesion_consolidation, mid)

        calculate_list = [
            lung_current, lesion_current, lung_lesion_current,
            left_lung, right_lung, left_lesion, right_lesion,

            lesion_current * raw_current, lung_lesion_current * raw_current,
            left_lesion * left_raw, right_lesion * right_raw,

            consolidation, lesion_consolidation,
            left_consolidation, right_consolidation
        ]

        [
            lung_volume, lesion_volume, lung_lesion_volume,
            left_lung_volume, right_lung_volume, left_lesion_volume, right_lesion_volume,

            weighted_lesion_volume, weighted_lung_lesion_volume,
            left_weighted_lesion_volume, right_weighted_lesion_volume,

            consolidation_volume, lesion_consolidation_volume,
            left_consolidation_volume, right_consolidation_volume
        ] = map(lambda x: np.sum(x) * voxel_size, calculate_list)

        z = get_z(lung_lesion_current)
        left_z = get_z(left_lesion)
        right_z = get_z(right_lesion)

        ratio = lung_lesion_volume / lung_volume
        left_ratio = left_lesion_volume / left_lung_volume
        right_ratio = right_lesion_volume / right_lung_volume
        res_list.append(
            {
                'lung': lung_volume,
                'lesion': lesion_volume,
                'ratio': ratio,
                'lung_lesion': lung_lesion_volume,
                'left_lung': left_lung_volume,
                'right_lung': right_lung_volume,
                'left_lesion': left_lesion_volume,
                'right_lesion': right_lesion_volume,
                'left_ratio': left_ratio,
                'right_ratio': right_ratio,

                'weighted_lesion': weighted_lesion_volume,
                'weighted_lung_lesion': weighted_lung_lesion_volume,
                'left_weighted_lesion': left_weighted_lesion_volume,
                'right_weighted_lesion': right_weighted_lesion_volume,

                'consolidation': consolidation_volume,
                'lesion_consolidation': lesion_consolidation_volume,
                'left_consolidation': left_consolidation_volume,
                'right_consolidation': right_consolidation_volume,

                'z': z,
                'left_z': left_z,
                'right_z': right_z,
            }
        )
        former_slice = current_slice
    return res_list


def predict_base_learners(base_learners, x):
    P = np.zeros((x.shape[0], len(base_learners)))
    print('Generating base learner predictions.')
    for i, (name, m) in enumerate(base_learners.items()):
        print('%s...' % name, end='', flush=False)
        p = m.predict_proba(x)
        P[:, i] = p[:, 1]
    print('done.')
    return P


"""## Visualization

|**Raw Data**|**Lung Segmentation**|**Lesion Segmentation**|
"""

num = 176  # 28
plt.subplots(figsize=(16, 9))
plt.subplot(1, 3, 1)
plt.imshow(raw_data[num], cmap='bone')
plt.subplot(1, 3, 2)
plt.imshow(lung[num], cmap='bone')
plt.subplot(1, 3, 3)
plt.imshow(lesion[num], cmap='bone')

"""## Calculate"""


def calculate(raw_data, lung, lesion, meta, patientID):
    meta = meta[meta['slice'] > 300]  # select thin scans
    meta = meta.reset_index()  # DataFrame index reset

    # patientID = '2020035365'

    res_list = calculate_volume(raw_data, lung, lesion, meta, crop=[0.17, 0.08])
    all_info = pd.concat([meta, pd.DataFrame(res_list)], axis=1)
    return res_list, all_info


res_list, all_info = calculate(raw_data, lung, lesion, meta, patientID=2020035365)

del raw_data, lung, lesion

# mild patient
raw_data_mild = read_from_nii(r'2020035021/*').astype('float32')
lung_mild = read_from_nii(r'2020035021_output/lung/*').astype('float32')
lesion_mild = read_from_nii(r'2020035021_output/covid/*').astype('float32')

res_list_mild, all_info_mild = calculate(raw_data_mild, lung_mild, lesion_mild, meta_mild, patientID=2020035021)
del raw_data_mild, lung_mild, lesion_mild

"""## Multi-time Visualization"""


def Multi_timepoint_Visualization(all_info, patientID, ):
    all_info['date'] = (pd.to_datetime(all_info['StudyDate']) - pd.to_datetime(all_info['StudyDate']).iloc[0]).map(
        get_days)

    colors = [sns.color_palette('Greens')[2], sns.color_palette('Reds')[4]]
    point_colors = [sns.color_palette('Greens')[3], sns.color_palette('Reds')[5]]

    plt.plot(all_info['date'], all_info['ratio'], color=point_colors[1], linestyle='-',
             label='{}: Lesion'.format(patientID), alpha=0.4)
    mild_info = all_info[all_info['Severe'] == 0]
    plt.scatter(mild_info['date'], mild_info['ratio'], color=colors[0], marker='o', s=100, alpha=1.0)
    severe_info = all_info[all_info['Severe'] > 0]
    plt.scatter(severe_info['date'], severe_info['ratio'], color=colors[1], marker='^', s=100, alpha=1.0)


print('Severe pateint vs Mild pateint')
Multi_timepoint_Visualization(all_info, patientID=2020035365)
plt.figure()
Multi_timepoint_Visualization(all_info_mild, patientID=2020035021)

"""## Prediction
### Load model
"""

with open('model/prediction.pkl', 'rb') as j:
    base_pred = pickle.load(j)

with open('model/min_max_prediction.json', 'r') as j:
    min_max_dict_pred = json.load(j)

with open('model/classification.pkl', 'rb') as j:
    base_cls = pickle.load(j)

with open('model/min_max_classification.json', 'r') as j:
    min_max_dict_cls = json.load(j)

feature = [
    'left_ratio', 'right_ratio',
    'left_lung', 'right_lung',
    'left_lesion', 'right_lesion',

    'left_weighted_lesion', 'right_weighted_lesion',

    'left_consolidation', 'right_consolidation',

    'left_z', 'right_z',
    'Age', 'sex',
]

"""## Preprocessing"""


# Preprocessing

def Preprocessing(all_info):
    # transfer PatientSex into 0/1
    all_info['sex'] = all_info['PatientSex'].map(get_sex)
    # normalize the z-position by dividing the slice number of the CT scan
    all_info['z'] = all_info['z'] / all_info['slice']
    all_info['left_z'] = all_info['left_z'] / all_info['slice']
    all_info['right_z'] = all_info['right_z'] / all_info['slice']

    X = all_info[feature].astype(np.float32)
    return X


X = Preprocessing(all_info)
X_mild = Preprocessing(all_info_mild)

"""## Per Scan Classification"""


def Per_Scan_Classification(X):
    x = min_max_scalar(np.array(X), np.array(min_max_dict_cls['min']), np.array(min_max_dict_cls['max']))
    P_pred = predict_base_learners(base_cls, np.array(x))
    p = P_pred.mean(axis=1)
    return p


p = Per_Scan_Classification(X)
print('Prediction of severe patient(per scan):\n{}\n'.format(p))
p_mild = Per_Scan_Classification(X_mild)
print('Prediction of mild patient(per scan):\n{}\n'.format(p_mild))

print('\n' + '*' * 10 + '\tSevere patient\t' + '*' * 10)
print('pred\t{} \ngt\t{} \nprob {}'.format((p > 0.5).astype('int'), np.array(all_info['Severe']), p))
print('\n' + '*' * 10 + '\tMild patient\t' + '*' * 10)
print('pred\t{} \ngt\t{} \nprob {}'.format((p_mild > 0.5).astype('int'), np.array(all_info_mild['Severe']), p_mild))

"""## First Two Scans"""


def First_Two_Scans(X):
    # first two scan
    x_list = X.iloc[1].tolist()[:-2] + X.iloc[0].tolist()
    # min max scale
    x = min_max_scalar(np.array(x_list), np.array(min_max_dict_pred['min']), np.array(min_max_dict_pred['max']))

    # Predition
    P_pred = predict_base_learners(base_pred, np.array([x]))
    return P_pred.mean()


print('\n' + '*' * 10 + '\tSevere patient\t' + '*' * 10)
print(First_Two_Scans(X))
print('\n' + '*' * 10 + '\tMild patient\t' + '*' * 10)
print(First_Two_Scans(X_mild))

"""# Comparison
We use first two CT scans to predict covid-19 disease progress. The prediction is consistent with the radiologist's suggestion.
"""

import numpy as np
from glob import glob
from utils_mri import get_itk_array
import cv2

from skimage.util import montage
from warnings import warn
import matplotlib.pyplot as plt


def montage_nd(in_img):
    if len(in_img.shape) > 3:
        return montage(np.stack([montage_nd(x_slice) for x_slice in in_img], 0))
    elif len(in_img.shape) == 3:
        return montage(in_img)
    else:
        warn('Dimension of input less than 3, returning original', RuntimeWarning)
        return in_img


def plot_Comparison(input_path, output_lung_path, output_covid_path, slice_count, timepoint_count, save_result=False):
    vol = np.zeros((timepoint_count, slice_count, 512, 512, 1))
    for nii_index in range(len(glob(input_path + '/*nii*'))):
        volume = get_itk_array(glob(input_path + '/*nii*')[nii_index])
        vol_slice = volume[slice_id[nii_index]:(slice_id[nii_index] + slice_count)]
        for i in range(vol_slice.shape[0]):
            vol_slice[i] = cv2.flip(vol_slice[i], 0)
        vol[nii_index] = np.expand_dims(vol_slice, -1)

    vol_lung = np.zeros((timepoint_count, slice_count, 512, 512, 1))
    for nii_index in range(len(glob(output_lung_path + '/*'))):
        volume = get_itk_array(glob(output_lung_path + '/*')[nii_index])
        vol_slice = volume[slice_id[nii_index]:(slice_id[nii_index] + slice_count)]
        for i in range(vol_slice.shape[0]):
            vol_slice[i] = cv2.flip(vol_slice[i], 0)
        vol_lung[nii_index] = np.expand_dims(vol_slice, -1)

    vol_covid = np.zeros((timepoint_count, slice_count, 512, 512, 1))  # (timepoint, slices num for each scan, H, W, 1)
    for nii_index in range(len(glob(output_covid_path + '/*'))):
        volume = get_itk_array(glob(output_covid_path + '/*')[nii_index])
        vol_slice = volume[slice_id[nii_index]:(slice_id[nii_index] + slice_count)]
        for i in range(vol_slice.shape[0]):
            vol_slice[i] = cv2.flip(vol_slice[i], 0)
        vol_covid[nii_index] = np.expand_dims(vol_slice, -1)

    # plot
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3,
                                        figsize=(30, 10)
                                        )

    ax1.imshow(montage_nd(vol[..., 0]), cmap='gray')
    ax1.set_title('Raw')
    ax2.imshow(montage_nd(vol_lung[..., 0]), cmap='gray')
    ax2.set_title('Lung')
    ax3.imshow(montage_nd(vol_covid[..., 0]), cmap='gray')
    ax3.set_title('Lesions')

    if save_result:
        plt.savefig('results.png')


input_path = '2020035365'
output_lung_path = '2020035365_output/lung'
output_covid_path = '2020035365_output/covid'

slice_id = [175, 162, 195, 195, 195, 195, 195, 195]
slice_count = 1  # slice number to plot for each scan.
plot_Comparison(input_path, output_lung_path, output_covid_path, 1, 8)

input_path = '2020035021'
output_lung_path = '2020035021_output/lung'
output_covid_path = '2020035021_output/covid'
slice_id = [200, 200, 200, 200, 200, 200]
plot_Comparison(input_path, output_lung_path, output_covid_path, 1, 6)


def plot_Progress_curve(all_info, patientID):
    plt.figure()
    all_info['date'] = (pd.to_datetime(all_info['StudyDate']) - pd.to_datetime(all_info['StudyDate']).iloc[0]).map(
        get_days)

    colors = [sns.color_palette('Greens')[2], sns.color_palette('Reds')[4]]
    point_colors = [sns.color_palette('Greens')[3], sns.color_palette('Reds')[5]]

    plt.plot(all_info['date'], all_info['ratio'], color=point_colors[1], linestyle='-',
             label='{}: Lesion'.format(patientID), alpha=0.4)
    mild_info = all_info[all_info['Severe'] == 0]
    plt.scatter(mild_info['date'], mild_info['ratio'], color=colors[0], marker='o', s=100, alpha=1.0)
    severe_info = all_info[all_info['Severe'] > 0]
    plt.scatter(severe_info['date'], severe_info['ratio'], color=colors[1], marker='^', s=100, alpha=1.0)


plot_Progress_curve(all_info, patientID=2020035365)
plot_Progress_curve(all_info_mild, patientID=2020035021)

"""## Progress of disease"""

from transparent_imshow import transp_imshow
from glob import glob
from utils_mri import get_itk_array


def data_Progress_of_disease(all_info, patientID, timepoint_count):
    gt = np.array(all_info['Severe'])

    raw_list = glob(r'{}/*nii*'.format(patientID))
    lung_list = glob(r'{}_output/lung/*'.format(patientID))
    covid_list = glob(r'{}_output/covid/*'.format(patientID))

    raw = np.zeros((timepoint_count, 512, 512))
    lesion = np.zeros((timepoint_count, 512, 512))

    for i, name in enumerate(raw_list):
        raw[i] = np.flip(get_itk_array(name).astype('float32')[slice_id[i]], axis=0)
    raw[raw < -1024] = -1024
    raw[raw > 512] = 512

    for i, name in enumerate(covid_list):
        lesion[i] = np.flip(get_itk_array(name).astype('float32')[slice_id[i]], axis=0)

    return raw, lesion, gt


def plot_progress(raw, lesion, gt, color_map='Reds', state='severe', timepoint_count=8
                  ):
    fig = plt.figure(figsize=(30, 9))

    for i in range(timepoint_count):
        plt.subplot(2, timepoint_count, i + 1)
        plt.imshow(raw[i], cmap='gray')
        plt.title('No.{} scan\n'.format(i + 1), fontsize=16)
        plt.xticks([]), plt.yticks([])

    for i in range(timepoint_count):
        plt.subplot(2, timepoint_count, timepoint_count + i + 1)
        plt.imshow(raw[i], cmap='gray')
        # plt.imshow(lesion[i], alpha=0.5, cmap=color_map)
        transp_imshow(lesion[i], cmap=color_map, alpha=0.7)
        plt.title('Prediction:{}\nGround Truth:{}'.format(round(p[i], 3), round(gt[i], 3)), fontsize=16)
        plt.xticks([]), plt.yticks([])

    fig.suptitle('Progress of {} patient in longitudinal study'.format(state), fontsize=26)
    plt.show()


slice_id = [175, 162, 195, 195, 195, 195, 195, 195]
raw, lesion, gt = data_Progress_of_disease(all_info, patientID=2020035365, timepoint_count=8)
plot_progress(raw, lesion, gt, state='severe', color_map='Reds', timepoint_count=8)

print('\n\n')
slice_id = [200, 200, 200, 200, 200, 200]
raw, lesion, gt = data_Progress_of_disease(all_info_mild, patientID=2020035021, timepoint_count=6)
plot_progress(raw, lesion, gt, state='mild', color_map='Reds', timepoint_count=6)

"""Predict the patient condiction using each CT scan."""
